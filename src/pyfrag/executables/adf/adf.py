import argparse as arg
import logging
import pathlib as pl
import shutil
import sys
from pathlib import Path

from input import process_user_input
from PyFragModules import handle_restart, pyfrag_driver, settings_from_ams_block, write_table
from scm.plams import config, finish, init

sys.path.append(str(pl.Path(__file__).parent.parent.parent))  # path to the adf_to_ams_input_converter.py file

"""
Pyfrag-ADF module
Authors: Xiaobo Sun; Thomas Soini; Siebe Lekanne Deprez

This program has the following functionalities:
1: Reads in a series of Linear Transit or IRC structures (coordinate files or t21).
2: For each point PyFrag generates single point calculations for the individual fragments (based on user defined fragments)
   and the whole complex system.
3: In the following the corresponding ADF calculations are conducted.
4: The program will generate a text file containing the decomposition energies plus other, user defined, values such as the strain energy.

Example use:
amspython PyFrag.py  --ircpath structuresIRC_CH3N.irc --fragment 1 3 4 --fragment 2 5 --strain 0 --strain 0 --adfinput basis.type=DZ

For the earlier version (PyFrag 2.0) please see http://www.few.vu.nl/~wolters/pyfrag/
"""


def setup_logging(job_name: str, log_level: int, input_file: Path) -> logging.Logger:
    logging.basicConfig(level=log_level, filename=input_file.with_suffix(".log"), filemode="w")
    logger = logging.getLogger("PyFrag-ADF")
    logger.info(f"Starting PyFrag-ADF for job: {job_name}")
    return logger


parser = arg.ArgumentParser(description="PyFrag ADF calculations from input file")
parser.add_argument("input_file", type=Path, help="Input file containing PyFrag configuration (e.g., [job_name].in)")

args = parser.parse_args()
# parser.add_argument("--name", "--jobname", "--job_name", type=str, help="Provide a name for the file generated by PLAMS")
# parser.add_argument("--log_level", type=str, nargs="*", help='detemine the log level of the program. Options are "debug", "info", "warning", "error", "critical"')

# parser.add_argument("--ircpath", type=str, action="append", nargs="*", help="DEPRECETAED IRC coordinate file")
# parser.add_argument("--irct21", type=str, action="append", nargs="*", help="DEPRECETAED IRC T21 coordinate file")
# parser.add_argument("--lt", type=str, action="append", nargs="*", help="DEPRECETAED LT or PESScan coordinate file")
# parser.add_argument("--coordfile", type=str, action="append", nargs="*", help="General indication of the coordinate file, supported types are .xyz, .amv, and .rkf")

# parser.add_argument("--fragment", "--fragment_indices", type=str, action="append", nargs="*", help="atom number for each fragment")
# parser.add_argument("--frag1_indices", "--fragment1_indices", type=str, action="append", nargs="*", help="atom number(s) (starting from 1) for the first fragment")
# parser.add_argument("--frag2_indices", "--fragment2_indices", type=str, action="append", nargs="*", help="atom number(s) (starting from 1) for the second fragment")

# parser.add_argument("--strain", type=float, action="append", nargs="*", help="the energy of the fragment. ")
# parser.add_argument("--frag1_energy", "--fragment1_energy", type=float, nargs=1, help="the energy of the first fragment.")
# parser.add_argument("--frag2_energy", "--fragment2_energy", type=float, nargs=1, help="the energy of the second fragment.")

# parser.add_argument("--VDD", type=int, action="append", nargs="*", help="print VDD charges per specified atom number")
# parser.add_argument("--hirshfeld", type=str, action="append", nargs="*", help="print hirshfeld charges per fragment (e.g., 'hirshfeld frag1 frag2')")

# parser.add_argument("--bondlength", type=float, action="append", nargs="*", help="print bond length")
# parser.add_argument("--angle", type=float, action="append", nargs="*", help="print angle")

# parser.add_argument("--irrepOI", type=str, nargs="*", action="append", help="print OI energy for point group symmetry irrep")

# parser.add_argument("--population", type=str, nargs="*", action="append", help="print population for fragment orbital")
# parser.add_argument("--overlap", type=str, nargs="*", action="append", help="print overlap between two fragment orbitals")
# parser.add_argument("--orbitalenergy", type=str, nargs="*", action="append", help="print orbital energy")

# parser.add_argument("--adfinputfile", type=str, nargs="*", help="a file containing adfinput parameters set of ADF after 2019")
# parser.add_argument("--old_adfinputfile", type=str, nargs="*", help="a file containing adfinput parameters set of ADF prior to 2019")

# parser.add_argument("--fragment1_EXTRA", type=str, nargs="*", help="a file containing adfinput parameters set for the first fragment")
# parser.add_argument("--fragment2_EXTRA", type=str, nargs="*", help="a file containing adfinput parameters set for the second fragment")
# parser.add_argument("--complex_EXTRA", type=str, nargs="*", help="a file containing adfinput parameters set for the complex system")


inputKeys = process_user_input(args.input_file)

# Set up logging
logger = setup_logging(inputKeys["job_name"], inputKeys["log_level"], args.input_file)

# Log settings if info level is configured
logger.info("\n".join([f"{key}: {val}" for key, val in inputKeys.items() if key not in ["adfinputfile", "old_adfinputfile", "fragment1_extra", "fragment2_extra", "complex_extra"]]))

# Handle restart | job_name is the name of the restart directory
inputKeys["jobstate"] = handle_restart(inputKeys["job_name"])

init(folder=inputKeys["job_name"])
workdir_path = config.default_jobmanager.workdir

# This (ugly) block of code is necessary to check if the user has provided an AMS input file or an old ADF input file
old_ADF_input = False
if inputKeys["adfinputfile"] is not None:
    settings_general = settings_from_ams_block(inputKeys["adfinputfile"])
elif inputKeys["old_adfinputfile"] is not None:
    raise ValueError("The old ADF input file is not supported in PyFrag 3.0. Please use an AMS input file instead.")
else:
    raise ValueError("No ADF input file provided. Please provide an AMS input file")

frag1_settings = settings_general.copy()  # copy is necessary to avoid linking errors when changing settings
frag2_settings = settings_general.copy()
complex_settings = settings_general.copy()

# Update (and possibly convert the <2019 ADF parsing to >2019 AMS) settings for the fragments and the complex
for extra_input, extra_settings in zip(["fragment1_extra", "fragment2_extra", "complex_extra"], [frag1_settings, frag2_settings, complex_settings]):
    if inputKeys[extra_input] is None:
        continue

    extra_input_path = inputKeys[extra_input]
    extra_settings.update(settings_from_ams_block(extra_input_path))


# Logging settings
for system, specific_sett in zip(["All systems", "Frag1", "Frag2", "Complex"], [settings_general, frag1_settings, frag2_settings, complex_settings]):
    logger.info(f"Settings for {system}:\n" + str(specific_sett))

# Execute PyFrag calculations: for each point on the IRC/LT, perform single point calculations for the fragments and the complex
tableValue, inputKeys = pyfrag_driver(inputKeys, frag1_settings, frag2_settings, complex_settings)

logger.info("Writing table to file and removing extra files")
write_table(tableValue, inputKeys["job_name"])

# Remove the restart directory if it exists.
if inputKeys["jobstate"] is not None:
    shutil.rmtree(inputKeys["jobstate"])
finish()
logging.info("PyFrag finished")
