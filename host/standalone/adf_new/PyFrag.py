import argparse as ag
import logging
import pathlib as pl
import shutil
import sys
from pathlib import Path

from input import process_user_input
from PyFragModules import PyFragDriver, handle_restart, settings_from_inputfile, write_table
from scm.plams import config, finish, init

sys.path.append(str(pl.Path(__file__).parent.parent.parent))  # path to the adf_to_ams_input_converter.py file
from adf_to_ams_input_converter import main_converter

"""
Pyfrag 3
Authors: Xiaobo Sun; Thomas Soini; Siebe Lekanne Deprez

This program has the following functionalities:
1: Reads in a series of Linear Transit or IRC structures (coordinate files or t21).
2: For each point PyFrag generates single point calculations for the individual fragments (based on user defined fragments)
   and the whole complex system.
3: In the following the corresponding ADF calculations are conducted.
4: The program will generate a text file containing the decomposition energies plus other, user defined, values such as the strain energy.

Example use:
amspython PyFrag.py  --ircpath structuresIRC_CH3N.irc --fragment 1 3 4 --fragment 2 5 --strain 0 --strain 0 --adfinput basis.type=DZ

For the earlier version (PyFrag 2.0) please see http://www.few.vu.nl/~wolters/pyfrag/
"""

logger = logging.getLogger("PyFrag")


parser = ag.ArgumentParser(description="Print user defined values")
parser.add_argument("--name", "--jobname", "--job_name", type=str, help="Provide a name for the file generated by PLAMS")
parser.add_argument("--log_level", type=str, nargs="*", help='detemine the log level of the program. Options are "debug", "info", "warning", "error", "critical"')

parser.add_argument("--ircpath", type=str, action="append", nargs="*", help="DEPRECETAED IRC coordinate file")
parser.add_argument("--irct21", type=str, action="append", nargs="*", help="DEPRECETAED IRC T21 coordinate file")
parser.add_argument("--lt", type=str, action="append", nargs="*", help="DEPRECETAED LT or PESScan coordinate file")
parser.add_argument("--coordfile", type=str, action="append", nargs="*", help="General indication of the coordinate file, supported types are .xyz, .amv, and .rkf")

parser.add_argument("--fragment", "--fragment_indices", type=str, action="append", nargs="*", help="atom number for each fragment")
parser.add_argument("--frag1_indices", "--fragment1_indices", type=str, action="append", nargs="*", help="atom number(s) (starting from 1) for the first fragment")
parser.add_argument("--frag2_indices", "--fragment2_indices", type=str, action="append", nargs="*", help="atom number(s) (starting from 1) for the second fragment")

parser.add_argument("--strain", type=float, action="append", nargs="*", help="the energy of the fragment. ")
parser.add_argument("--frag1_energy", "--fragment1_energy", type=float, nargs=1, help="the energy of the first fragment.")
parser.add_argument("--frag2_energy", "--fragment2_energy", type=float, nargs=1, help="the energy of the second fragment.")

parser.add_argument("--VDD", type=int, action="append", nargs="*", help="print VDD charges per specified atom number")
parser.add_argument("--hirshfeld", type=str, action="append", nargs="*", help="print hirshfeld charges per fragment (e.g., 'hirshfeld frag1 frag2')")

parser.add_argument("--bondlength", type=float, action="append", nargs="*", help="print bond length")
parser.add_argument("--angle", type=float, action="append", nargs="*", help="print angle")

parser.add_argument("--irrepOI", type=str, nargs="*", action="append", help="print OI energy for point group symmetry irrep")

parser.add_argument("--population", type=str, nargs="*", action="append", help="print population for fragment orbital")
parser.add_argument("--overlap", type=str, nargs="*", action="append", help="print overlap between two fragment orbitals")
parser.add_argument("--orbitalenergy", type=str, nargs="*", action="append", help="print orbital energy")

parser.add_argument("--adfinputfile", type=str, nargs="*", help="a file containing adfinput parameters set of ADF after 2019")
parser.add_argument("--old_adfinputfile", type=str, nargs="*", help="a file containing adfinput parameters set of ADF prior to 2019")

parser.add_argument("--fragment1_EXTRA", type=str, nargs="*", help="a file containing adfinput parameters set for the first fragment")
parser.add_argument("--fragment2_EXTRA", type=str, nargs="*", help="a file containing adfinput parameters set for the second fragment")
parser.add_argument("--complex_EXTRA", type=str, nargs="*", help="a file containing adfinput parameters set for the complex system")


inputKeys = process_user_input(parser)

# Set up logging
logfile = inputKeys["job_name"] + ".log"
logging.basicConfig(filename=logfile, filemode="w", level=inputKeys["log_level"])
logger.critical(f"Starting PyFrag calculations with log level {logging.getLevelName(inputKeys['log_level'])}")

# Log settings if info level is configured
logger.info("\n".join([f"{key}: {val}" for key, val in inputKeys.items()]))

# Handle restart | job_name is the name of the restart directory
inputKeys["jobstate"] = handle_restart(inputKeys["job_name"])

init(folder=inputKeys["job_name"])
workdir_path = config.default_jobmanager.workdir

# This (ugly) block of code is necessary to check if the user has provided an AMS input file or an old ADF input file
old_ADF_input = False
if inputKeys["adfinputfile"] is not None:
    settings_general = settings_from_inputfile(inputKeys["adfinputfile"])
elif inputKeys["old_adfinputfile"] is not None:
    logger.critical("Detecting an old ADF inputfile (prior to 2019).\nAttempting to convert the input to settings WHICH MAY NOT BE SUCCESFUL...")
    settings_general = main_converter((inputKeys["old_adfinputfile"]))
    old_ADF_input = True
else:
    raise ValueError("No ADF input file provided. Please provide an AMS input file or an old ADF input file.")

settings_Frag1 = settings_general.copy()  # copy is necessary to avoid linking errors when changing settings
settings_Frag2 = settings_general.copy()
settings_Complex = settings_general.copy()

# Update (and possibly convert the <2019 ADF parsing to >2019 AMS) settings for the fragments and the complex
for extra_input, extra_settings in zip(["fragment1_extra", "fragment2_extra", "complex_extra"], [settings_Frag1, settings_Frag2, settings_Complex]):
    if inputKeys[extra_input] is None:
        continue

    extra_input_path = inputKeys[extra_input]

    if old_ADF_input:
        extra_settings.update(main_converter(extra_input_path))
    else:
        extra_settings.update(settings_from_inputfile(extra_input_path))


# Logging settings
for system, specific_sett in zip(["All systems", "Frag1", "Frag2", "Complex"], [settings_general, settings_Frag1, settings_Frag2, settings_Complex]):
    logger.info(f"Settings for {system}:\n" + str(specific_sett))

# Execute PyFrag calculations: for each point on the IRC/LT, perform single point calculations for the fragments and the complex
tableValue, inputKeys = PyFragDriver(inputKeys, settings_Frag1, settings_Frag2, settings_Complex)

logger.info("Writing table to file and removing extra files")
write_table(tableValue, inputKeys["job_name"])

# Remove extra files
workdir_parent = Path(workdir_path).parent
for job_name in ["sub", "adfinputfile", "old_adfinputfile", "complex_EXTRA", "fragment1_EXTRA", "fragment2_EXTRA"]:
    file_path = workdir_parent / job_name
    if file_path.exists():
        file_path.unlink()

# Remove the restart directory if it exists.
if inputKeys["jobstate"] is not None:
    shutil.rmtree(inputKeys["jobstate"])
finish()
logging.info("PyFrag finished")
